列表
-----------

列表或是空的 或者由 头跟尾组成（head  tail ）

空列表可以这样表示：  []

头与尾用 管道 符号 分割 : |

一个元素的列表：  [3]  可看做  head是3 尾是空列表的列表  [3 | [] ]
当看到管道符号时  我们说其左侧是 头 右侧是 尾

再比如： [2 , 3 ] 可写为 [2 | [3 | [] ] ]

 左侧添加元素：  [1 | [ 2 |  [ 3 |[] ] ] ]
                 [1   , 2   ,3 ]
                 
                 
在模式匹配中 模式可以是列表

[ head | tail ] = [1,2,3 ]             
    
## iex 解析字符串
    
字符串有两种形式 双引号 或者单引号括起来 的字符
    
    对于单引号 'cat'   看做整数码点组成的列表 : 99 ， 97 ， 116

但当看到 [ 99 , 97 , 116 ] 时 不清楚到底表示的是整数列表呢 还是 'cat' 
此时 它 用了启发式方法 如果列表中的值都是可打印的字符 就将之显示为一个字符串！

~~~[elixir]

        iex(1)> [ 99 ,97 ,116 ]
        'cat'
    
       iex(2)> [ 99 ,97 ,116 , 0 ] # 0 是不可打印字符 所以整个列表视为整数列表而不是字符串！
       [99, 97, 116, 0]
~~~
    
## 使用头和尾 来处理列表
    
我们可以把列表分为头和尾 我们可以用一个值跟一个列表构造一个列表 ，值将变为 新列表的 头 ，列表变为新列表的尾 。  
  
列表跟递归经常一起出现 如同fish跟chips
  
来看看 列表长度

-  空列表的长度是 0
-  列表的长度是 1 + 列表尾的长度
   
实现：

~~~[elixir]

    defmodule MyList do
      @moduledoc false
    
      def len([]) , do: 0
    
      def len([head | tail ]) , do: 1 + len(tail)
    
    end

~~~
    
最诡异的是 第二个len定义 len([head | tail ] ) 匹配任何非空的列表
    
编译上面的文件会报一个警告：
    >   my_list.ex:6: warning: variable head is unused
    
在上面的模块中并没有使用便利head，为了不再让编译器吵闹，所以可以用_  下划线 来忽略某些匹配。它扮演占位符的角色，也可以
在变量名前面冠以下划线。 这种技术可以关闭因没有使用变量而产生的警告 

~~~[elixir]

       def len([_head | tail ]) , do: 1 + len(tail)

~~~
    