OTP
============

OTP 代表 （Open Telegram Platform） 开放电文平台 提供了常用的解决方案

常常涉及： 应用发现 ， 错误探测和管理 ，热码切换 ，以及服务器结构 。

OTP早期是用来构造电话交换和交换机的。但这些设备跟我们想要的任何大型线上程序有着相似特征 。所以现在OTP成为了通用工具 用来
开发，管理大型系统 。

OTP实际是一个捆包 包括Erlang ，一个数据库（Mnesia），以及一个不可数的库集合 ，它也定义了你应用程序的结构 。和其他任何大型，复杂
框架类似 有着太多的内容去学习 。

我们其实一直在使用OTP -- mix ，Elixir编译器 ，但都是隐式使用 ，现在我们要显式用他们了.

## 一些OTP定义
OTP 使用应用层次这个术语来定义系统。一个应用程序由一个或者多个进程构成 。这些进程遵从OTP中的一些惯例 ，称为 behaviors
有一个行为被用于通用目的的服务器，其中的一个用于实现事件处理器 ，还有一个用于有限状态机 。这些行为的实现会运行在他们自己的进程中（
可能伴有辅助进程）。

有一个特殊的行为者 ，称为supervisor ，监控着这些进程的监控 并实现了重启策略（当进程需要时）

## OTP 服务器
许多服务器有着相似的需求集 。所以OTP提供了所有完成这些底层工作的库 。

当我们写一个OTP服务器时 ，我们设计一个模块 ，包含一个或者多个回调函数 这些函数有着标准的名称 ，OTP会在特定情形来调用合适
的回调的 。（调用合适的回调去处理特定情境） 。比如 ，当某人发送请求给我们的server。OTP会调用我们的handle_call 函数 ，传递
一个request ，调用者caller ，当前服务状态server state 。我们的函数通过返回一个元祖来响应他 ，元祖包括一个将会被采用的动作，
请求的返回值，和一个更新后的状态 。

### 状态和单服务器

回到我们计算列表总和的例子 ，我们遇到了一个accumulator（聚合器 累加器）的概念：
~~~
    
    defmodule MyList do
        def sum([] , total) , do: total
        def sum([head | tail ] ,total) , do: sum(tail , head+total)
    end 
~~~
参数total 在函数在列表中滚动（trundle down the list）时维护了状态

这些参数是用于状态信息的 。

现在想想我们的服务器， 他们使用递归去循环 ，在每次调用时处理一个请求 ，所以他们也可以在递归调用中用参数传递状态给他们自己。
这就是OTP为我们做的一件事情 。我们的处理器函数 获取到传递的当前状态（最后一个参数） ，之后返回一个可能被更改的状态（同其他东东一起）
。无论函数返回什么状态，他将被传给下一个请求处理器 。

## 我们第一个OTP 服务器

一个最简OTP server ， 当启动时你传递给他一个数字 ，他将变成当前服务器的当前状态 ，当你通过:next_number 请求来调用它时，
他会返回当前状态给调用者 ，与此同时 递增这个状态 ，为下次调用做准备 。基本上 每次你对他的调用你会得到一个更新的序列化数字。
