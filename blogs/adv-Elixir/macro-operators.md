Macros and Operators
-------------
(危险地带)

我们可以用宏重载一元和二元运算符在elixir中。这样做，我们需要先移除已经存在的定义。

比如，操作符 + （两数字求和） 被定义在Kernel 模块中。 为了移除Kernel中的定义并替换为我们自己的。我们需要做下面的事情（
重定义加法连接左参和右参的字符串表示）
~~~

    defmodule Operators do
        defmacro a + b do
            quote do
                quote do
                    to_string(unquote(a)) <> to_string(unquote(b))
                end
            end
        end
    end
~~~
注意宏定义是语法分析域 --- + 操作符从导入Operators模块开始那个点 被重载 直到导入其模块的底部。
我们也可以在单独方法的内部做导入，域范围也只是那个方法。

Macro模块有两个方法，其可以列出一元和二元操作符
~~~

    iex(2)> require Macro
    nil
    iex(3)> Macro.binary_ops
    [:===, :!==, :==, :!=, :<=, :>=, :&&, :||, :<>, :++, :--, :\\, :::, :<-, :..,
     :|>, :=~, :<, :>, :->, :+, :-, :*, :/, :=, :|, :., :and, :or, :when, :in, :~>>,
     :<<~, :~>, :<~, :<~>, :<|>, :<<<, :>>>, :|||, :&&&, :^^^, :~~~]
    iex(4)> Macro.unary_ops
    [:!, :@, :^, :not, :+, :-, :~~~, :&]
~~~

## 挖的再深些
Code和Macro模块包含操作内部代码表示的函数

看看Kernel模块的源码 ， 如 def defmodule alias 等 如果我们看源码 我们会看到调用序列，而然其体是缺失的，因为宏被定义在Elixir
源码中。

## 还能再深些？
这里有一个简单表达式的内部表示
>   
    iex(5)> quote do: 1+2
    {:+, [context: Elixir, import: Kernel], [1, 2]}

这只是一个三元素的元祖，在此例中，第一个元素是函数（或者宏） ，第二个是内部用途的元数据，第三个是参数列表。

我们知道我们可以计算这段代码用eval_quoted ,我们可以减少敲击元数据信息(不用模拟元数据信息)
>   iex(1)> Code.eval_quoted {:+ , [] , [1,3] }
    {4, []}
    
至此我们开始看到 一个homoiconic语言的前景（和其危险）。因为代码只是元祖 因为我们可以操纵这些元祖，我们可以重写既存（已存在）
函数的定义。我们可以凭空创建新的代码。我们可以安全地做这些事 因为我们可以控制变更和变量访问的域。
   
接下来我们看看协议，一种为内建代码添加功能的方式 也可以集成我们自己的代码到别人的模块中。   
