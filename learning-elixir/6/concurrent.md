并行编程 -  使用进程来做分治 
================

已经看过Elixir语法基础：modules functions types branching recursion 和模式匹配。这些东西已经可以应付大部分事情了，虽不是
太优雅 但已经差不多完了。
然而 ，有另一个世界浮现出来了  -- 并发编程

芯片制造 多核 桌面机 平板 手机

作为开发人员我们的问题就出现了 -- 当前的语言经常被设计为 单线程，单路径 单个执行上下文。
多数语言对使用多核并没有暴露好的设施，这就是ERTS和Erlang/Tlixir 真正让他们与众不同的地方。并发被内置在语言中了，也是语言
的首要约束，如果不能很好的处理并发，语言就是失败额。

## 并行计算和并发计算

这两个概念是不一样的。

我们可以使用 **context**上下文此词来讲线程或者而进程。明显地他们是不同的 但某种角度他们共享一些概念 相对于并行 VS 并发

并行计算 只是简单的两个或者多个同时地 上下文的执行 。
被执行的上下文是同时地，在执行间没有切换和中断 。

并发处理有些不同，他可以表现为并行 但实际上对并行不保证 。 比如 两个将要执行的上下文，但竞争同一个CPU 。调度器在二者间执行
，基于一些标准(缓存失效 死线优先级 ， 分支失效 ，或者其他)
在并发执行中，处理可能是并行的，但CPU 可能实际上被快速地在任务间切换。

单核机器运行多个进程就是并发执行的极好的例子。每个进程看似同时计算的，但是 ， 实际上 是被中断的，挂起的 和重新恢复多次。
甚至千万次每秒钟 。

假设给此机器添加更多的核 ，机器就可以并行地执行更多进程 ，但人就并发地做千万次这样的事情 。

## Erlang 进程和 OS 进程

当在Erlang上下文中讲进程时 ， 我们经常指的是Erlang 进程 而不是 OS进程 。
他们有很微妙但很重要的区别。
OS 进程被操作系统 调度 控制 ，或者更正确的 是内核 。内核的任务 关于 入队， 出队 ， 编组数据 ，内存分配 ，其他任务需要
平滑的进程执行。Erlang进程 ，是对于Erangl VM（BEAM）的本地进程 。ERTS被视为内核在此情况下 。它管理负责这些进程的调度和管理
。

另一个重要区别是重量问题 ，典型地，当考虑OS进程时，他们是重量级的 要处理的大块头的对象 ，不考虑进程交互的话。
Erlang 进程相反，是非常轻量级的，对单个的Erlang 虚拟机有成千上万进程同时运行很正常（进程 数量 可以相当 OO语言中的对象数量）

## 并行map
